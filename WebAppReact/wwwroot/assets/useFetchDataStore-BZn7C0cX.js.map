{"version":3,"file":"useFetchDataStore-BZn7C0cX.js","sources":["../../front-react/src/stores/useFetchDataStore.jsx"],"sourcesContent":["import { create } from \"zustand\";\r\n\r\n// Función para realizar fetch\r\nconst fetchData = async (\r\n  url,\r\n  method = \"GET\",\r\n  body = null,\r\n  contentType = \"application/json\",\r\n  token = null\r\n) => {\r\n  const options = {\r\n    method,\r\n    headers: {\r\n      \"Content-Type\": contentType,\r\n    },\r\n    body: body ? JSON.stringify(body) : null,\r\n  };\r\n\r\n  if (body instanceof FormData) {\r\n    options.body = body;\r\n  } else {\r\n    options.headers[\"Content-Type\"] = contentType;\r\n    options.body = body ? JSON.stringify(body) : null;\r\n  }\r\n  // Añadir el token al encabezado si está presente\r\n  if (token) {\r\n    options.headers[\"Authorization\"] = `Bearer ${token}`;\r\n  }\r\n\r\n  const response = await fetch(url, options);\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`HTTP error! status: ${response.status}`);\r\n  }\r\n  return response.json();\r\n};\r\n\r\nconst useFetchDataStore = create((set, get) => ({\r\n  data: [],\r\n  loading: false,\r\n  error: null,\r\n\r\n  // Método para realizar peticiones y almacenar los datos\r\n  callApi: async (\r\n    url,\r\n    method = \"GET\",\r\n    body = null,\r\n    contentType = \"application/json\",\r\n    token = null\r\n  ) => {\r\n    set({ loading: true, error: null });\r\n    try {\r\n      const responseData = await fetchData(\r\n        url,\r\n        method,\r\n        body,\r\n        contentType,\r\n        token\r\n      );\r\n      set((state) => ({\r\n        data: { ...state.data, [url]: responseData },\r\n        loading: false,\r\n      }));\r\n    } catch (error) {\r\n      set({ loading: false, error: error.message });\r\n    }\r\n  },\r\n\r\n  // Método para obtener datos\r\n  getData: (url) => get().data[url] || [],\r\n\r\n  // Método para refrescar datos\r\n  refreshData: async (url, method = \"GET\", body = null) => {\r\n    await get().callApi(url, method, body);\r\n  },\r\n\r\n  // Método de búsqueda en los datos\r\n  searchData: (url, query) => {\r\n    const data = get().data[url] || [];\r\n    return data.filter((item) =>\r\n      JSON.stringify(item).toLowerCase().includes(query.toLowerCase())\r\n    );\r\n  },\r\n}));\r\n\r\nexport default useFetchDataStore;\r\n"],"names":["fetchData","url","method","body","contentType","token","options","response","useFetchDataStore","create","set","get","responseData","state","error","query","item"],"mappings":"mCAGA,MAAMA,EAAY,MAChBC,EACAC,EAAS,MACTC,EAAO,KACPC,EAAc,mBACdC,EAAQ,OACL,CACH,MAAMC,EAAU,CACd,OAAAJ,EACA,QAAS,CACP,eAAgBE,CAClB,EACA,KAAMD,EAAO,KAAK,UAAUA,CAAI,EAAI,IAAA,EAGlCA,aAAgB,SAClBG,EAAQ,KAAOH,GAEPG,EAAA,QAAQ,cAAc,EAAIF,EAClCE,EAAQ,KAAOH,EAAO,KAAK,UAAUA,CAAI,EAAI,MAG3CE,IACFC,EAAQ,QAAQ,cAAmB,UAAUD,CAAK,IAGpD,MAAME,EAAW,MAAM,MAAMN,EAAKK,CAAO,EAErC,GAAA,CAACC,EAAS,GACZ,MAAM,IAAI,MAAM,uBAAuBA,EAAS,MAAM,EAAE,EAE1D,OAAOA,EAAS,MAClB,EAEMC,EAAoBC,EAAO,CAACC,EAAKC,KAAS,CAC9C,KAAM,CAAC,EACP,QAAS,GACT,MAAO,KAGP,QAAS,MACPV,EACAC,EAAS,MACTC,EAAO,KACPC,EAAc,mBACdC,EAAQ,OACL,CACHK,EAAI,CAAE,QAAS,GAAM,MAAO,IAAM,CAAA,EAC9B,GAAA,CACF,MAAME,EAAe,MAAMZ,EACzBC,EACAC,EACAC,EACAC,EACAC,CAAA,EAEFK,EAAKG,IAAW,CACd,KAAM,CAAE,GAAGA,EAAM,KAAM,CAACZ,CAAG,EAAGW,CAAa,EAC3C,QAAS,EACT,EAAA,QACKE,EAAO,CACdJ,EAAI,CAAE,QAAS,GAAO,MAAOI,EAAM,QAAS,CAC9C,CACF,EAGA,QAAUb,GAAQU,IAAM,KAAKV,CAAG,GAAK,CAAC,EAGtC,YAAa,MAAOA,EAAKC,EAAS,MAAOC,EAAO,OAAS,CACvD,MAAMQ,EAAI,EAAE,QAAQV,EAAKC,EAAQC,CAAI,CACvC,EAGA,WAAY,CAACF,EAAKc,KACHJ,EAAI,EAAE,KAAKV,CAAG,GAAK,CAAA,GACpB,OAAQe,GAClB,KAAK,UAAUA,CAAI,EAAE,YAAA,EAAc,SAASD,EAAM,aAAa,CAAA,CAGrE,EAAE"}